{
  "language": "Solidity",
  "sources": {
    "contracts/MiMCSponge.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\r\n// pragma solidity =0.8.17;\r\n\r\n\r\n// import \"./interfaces/IMiMCSponge.sol\";\r\n\r\n\r\n\r\n\r\n// // we are implementing the MIMCSponge; \r\n// contract HasherSponge is IMiMCSponge {\r\n\r\n \r\n     \r\n\r\n//     uint8  private nRounds = 20;\r\n//     // the prime field from \r\n//     uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n\r\n\r\n//     // so the first thing we have to do is we need to have the c .. the constants \r\n//     // c is the constant for the MIMC\r\n\r\n//     uint256[20] private c  = [\r\n         \r\n//         0,\r\n//         50281665087298506398025612566576429713867677490132600550666462694043893096041,\r\n//         103379909872542805421140796569816612169295853039398864686417708805632325131067,\r\n//         8586855295369424941935330807803134896681691157372145643883923355615550583342,\r\n//         88370656788028663357054378704610607924064488825154270360610943785853808437587,\r\n//         80176421270384287601374674158600932358010734845730789240551909743287128659181,\r\n//         9528216501708403574105991674956722258584542856277612000094300594947363066680,\r\n//         17669521326439010530034895428020811097501471394802251414069319741829373029771,\r\n//         58631108220768371139580724699814589444344114830955946945895965299721834508558,\r\n//         95100372926602787001593384948116402864394899303403306696193376400358861223081,\r\n//         107818123855601272583072257161782347474009303555329756033680199767831149000646,\r\n//         1428802693023461914036224180230354801713259560901182204682110762944690749665,\r\n//         98212930817416947604707053186021029626372029290120295000826942586189933631243,\r\n//         77616516200106068767337201799487094912595296259220362763818164121851717084940,\r\n//         58083512051912905109576180677305052842815684860310822645756294409625272816797,\r\n//         105110014696781952118374891655100624045293309813267472668843831137609860690906,\r\n//         63510890172120891876331835536756515461281359754185699836571235972391984807120,\r\n//         71776992183853185402707224684473119966100872667793758637767495260560955881686,\r\n//         38521477329328306708598228213328859227759684577497015037882397799544926522561,\r\n//         26398687503444292499683437635338801937597812449300890475753400819372208451565\r\n\r\n\r\n    \r\n//     ];\r\n\r\n\r\n\r\n \r\n// function createNewHashFromTwo( uint256[2] memory inputs,  uint256 k) public view  returns(uint256){\r\n\r\n  \r\n\r\n\r\n//     uint256 rBits = 0;\r\n//     uint256 cBits = 0;\r\n\r\n//     for (uint256 i = 0; i<inputs.length; i++){\r\n               \r\n//          rBits =  addmod(rBits, inputs[i] , p);\r\n\r\n//             (rBits, cBits) = mimcHasherFeistal(rBits, cBits, k);\r\n\r\n\r\n\r\n//     }\r\n     \r\n//     return rBits;\r\n\r\n\r\n\r\n\r\n// }\r\n\r\n//   // lets create the function MIMC = (x + k + c) ^5 but for each roun\r\n// function mimcHasherFeistal(uint256 _iL, uint256 _iR, uint256 k) public  view returns(uint256, uint256){\r\n//           uint256 lastR = _iR;\r\n//           uint256 lastL = _iL;\r\n       \r\n\r\n//           uint base;\r\n//           uint base2;\r\n//           uint256 base4;\r\n//           uint256 temp;\r\n \r\n          \r\n          \r\n//           for (uint256 i = 0; i< nRounds; i++){\r\n//             // x + k+  c\r\n//             // at index 0    c = 0 \r\n//             base = addmod(lastR, k, p );\r\n//             base = addmod(base , c[i],p);\r\n//             base2 = mulmod(base, base, p);\r\n//             base4 = mulmod(base2, base2, p);\r\n           \r\n\r\n//             temp = lastR;\r\n\r\n//             lastR =  addmod(mulmod(base4, base2, p), lastL, p );\r\n//             lastL = temp;\r\n\r\n                  \r\n//           }\r\n\r\n//           return (lastL, lastR);\r\n\r\n\r\n\r\n    \r\n// }\r\n\r\n\r\n\r\n// }\r\n\r\n\r\n\r\n\r\n\r\npragma solidity =0.8.17;\r\n\r\ncontract Hasher {\r\n    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256[20] c = [\r\n        0,\r\n        25823191961023811529686723375255045606187170120624741056268890390838310270028,\r\n        71153255768872006974285801937521995907343848376936063113800887806988124358800,\r\n        51253176922899201987938365653129780755804051536550826601168630951148399005246,\r\n        66651710483985382365580181188706173532487386392003341306307921015066514594406,\r\n        45887003413921204775397977044284378920236104620216194900669591190628189327887,\r\n        14399999722617037892747232478295923748665564430258345135947757381904956977453,\r\n        29376176727758177809204424209125257629638239807319618360680345079470240949145,\r\n        13768859312518298840937540532277016512087005174650120937309279832230513110846,\r\n        54749662990362840569021981534456448557155682756506853240029023635346061661615,\r\n        25161436470718351277017231215227846535148280460947816286575563945185127975034,\r\n        90370030464179443930112165274275271350651484239155016554738639197417116558730,\r\n        92014788260850167582827910417652439562305280453223492851660096740204889381255,\r\n        40376490640073034398204558905403523738912091909516510156577526370637723469243,\r\n        903792244391531377123276432892896247924738784402045372115602887103675299839,\r\n        112203415202699791888928570309186854585561656615192232544262649073999791317171,\r\n        114801681136748880679062548782792743842998635558909635247841799223004802934045,\r\n        111440818948676816539978930514468038603327388809824089593328295503672011604028,\r\n        64965960071752809090438003157362764845283225351402746675238539375404528707397,\r\n        98428510787134995495896453413714864789970336245473413374424598985988309743097\r\n    ];\r\n\r\n    function MiMC5Feistel(uint256 _iL, uint256 _iR, uint256 _k) internal view returns(uint256 oL, uint256 oR) {\r\n        uint8 nRounds = 20;\r\n\r\n        uint256 lastL = _iL;\r\n        uint256 lastR = _iR;\r\n\r\n        uint256 mask;\r\n        uint256 mask2;\r\n        uint256 mask4;\r\n        uint256 temp;\r\n\r\n        for(uint8 i = 0; i < nRounds; i++){\r\n            mask = addmod(lastR, _k, p);\r\n            mask = addmod(mask, c[i], p);\r\n            mask2 = mulmod(mask, mask, p);\r\n            mask4 = mulmod(mask2, mask2, p);\r\n            mask = mulmod(mask4, mask, p);\r\n\r\n            temp = lastR;\r\n            lastR = addmod(lastL, mask, p);\r\n            lastL = temp;\r\n        }\r\n\r\n        return (lastL, lastR);\r\n    }\r\n    function MiMC5Sponge(uint256[2] memory _ins, uint256 _k) external view returns(uint256 h) {\r\n        uint256 lastR = 0;\r\n        uint256 lastC = 0;\r\n\r\n        for(uint8 i = 0; i < _ins.length; i++){\r\n            lastR = addmod(lastR, _ins[i], p);\r\n            (lastR, lastC) = MiMC5Feistel(lastR, lastC, _k);\r\n        }\r\n\r\n        h = lastR;\r\n    }\r\n}"
    },
    "contracts/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}"
    },
    "contracts/Tornado.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\r\n// pragma solidity =0.8.17;\r\n\r\n\r\n// import \"./Reentrancy.sol\";\r\n// import \"./MiMCSponge.sol\";\r\n// import \"./interfaces/IMiMCSponge.sol\";\r\n\r\n// contract Tornado is ReentrancyGuard {\r\n\r\n//      IMiMCSponge mimcSponge;\r\n//     constructor(address spongeContractAddress){\r\n//         mimcSponge = IMiMCSponge(spongeContractAddress);\r\n//     }\r\n\r\n// event Deposit(   uint256[10]  hashDirections,\r\n//         uint256[10]  hashPairings, uint256 rootHash);\r\n\r\n//     uint8 treeHeight = 10;\r\n//     mapping(uint256 => bool) commitments;\r\n//     mapping(uint256 => bool) allRoots;\r\n\r\n//     mapping(uint256 => uint256) lastLevelhash;\r\n\r\n//     // we are going to use this to track each and every leafIndex to know if the merkle tree is full cause  if this is >= to the 2^ of the treeHeight then the merkle tree is full\r\n  \r\n\r\n//     uint256[10] private levelDefaults = [\r\n//         23183772226880328093887215408966704399401918833188238128725944610428185466379,\r\n//         24000819369602093814416139508614852491908395579435466932859056804037806454973,\r\n//         90767735163385213280029221395007952082767922246267858237072012090673396196740,\r\n//         36838446922933702266161394000006956756061899673576454513992013853093276527813,\r\n//         68942419351509126448570740374747181965696714458775214939345221885282113404505,\r\n//         50082386515045053504076326033442809551011315580267173564563197889162423619623,\r\n//         73182421758286469310850848737411980736456210038565066977682644585724928397862,\r\n//         60176431197461170637692882955627917456800648458772472331451918908568455016445,\r\n//         105740430515862457360623134126179561153993738774115400861400649215360807197726,\r\n//         76840483767501885884368002925517179365815019383466879774586151314479309584255\r\n//     ];\r\n\r\n\r\n\r\n//     function deposit(uint256 commitmentHash) public  payable nonReentrant(){\r\n//         uint256 leafIndex = 0;\r\n    \r\n//         uint256[10] memory hashDirections;\r\n//         uint256[10] memory hashPairings;\r\n//         uint256  leftPair;\r\n//         uint256 rightPair;\r\n\r\n//         uint256[2] memory _insForMimC;\r\n\r\n//         uint256 currenthash = commitmentHash;\r\n\r\n        \r\n//            uint256 currentIdx = leafIndex;\r\n           \r\n//         require(msg.value > 0, \"you need to deposit more than 0 eth\");\r\n\r\n//                 // we check if the merkle tree is full   2 ^height of the tree tell us the size of the merkle tree\r\n//         // we need to place the commitment hash into the tree \r\n//         require(leafIndex < 2**treeHeight, \"tree is full cannot make a deposit\");\r\n\r\n//         // we need to check commitment hash exist cause we cannot repeat two deposits \r\n\r\n//         require(!commitments[commitmentHash], \"duplicates are not allowed \");\r\n        \r\n//         for (uint8 i = 0 ; i< treeHeight ; i++){\r\n\r\n   \r\n\r\n\r\n\r\n// // this means that are on the left \r\n//             if (currentIdx %2 == 0){\r\n//                 leftPair = currenthash;\r\n//                 rightPair = levelDefaults[i];\r\n//                 hashDirections[i] = 0;\r\n//                 hashPairings[i] = levelDefaults[i];\r\n\r\n\r\n//             }else{\r\n\r\n\r\n//                     leftPair = levelDefaults[i];\r\n//                    rightPair = currenthash;\r\n//                     hashDirections[i] = 1;\r\n//                     hashPairings[i] = lastLevelhash[i];\r\n//             }\r\n\r\n//             lastLevelhash[i] = currenthash;\r\n\r\n//              _insForMimC[0] = leftPair;\r\n//              _insForMimC[1] = rightPair;\r\n//             (uint256 h) = mimcSponge.createNewHashFromTwo{value:150000}(_insForMimC, commitmentHash);\r\n\r\n//             currenthash = h;\r\n//             currentIdx =  currentIdx/2;\r\n            \r\n\r\n\r\n//         }\r\n\r\n//         uint256 newRoot = currenthash;\r\n//         allRoots[newRoot] = true;\r\n\r\n       \r\n\r\n//         leafIndex = leafIndex + 1;\r\n//         commitments[commitmentHash] = true;\r\n\r\n//         emit Deposit(hashDirections, hashPairings, newRoot);\r\n\r\n\r\n//         // after we deposit to the leaf we need to get the path of the merkle tree to the node \r\n\r\n\r\n       \r\n\r\n        \r\n\r\n\r\n//     }\r\n\r\n\r\n//     function withdraw() public nonReentrant() {\r\n\r\n//     }\r\n// }\r\n\r\n\r\npragma solidity =0.8.17;\r\n\r\nimport \"./MiMCSponge.sol\";\r\nimport \"./ReentrancyGuard.sol\";\r\n\r\ninterface IVerifier {\r\n    function verifyProof(uint[2] memory a, uint[2][2] memory b, uint[2] memory c, uint[3] memory input) external;\r\n}\r\n\r\ncontract Tornado is ReentrancyGuard {\r\n    // address verifier;\r\n    Hasher hasher;\r\n    address verifier;\r\n\r\n    uint8 public treeLevel = 10;\r\n    uint256 public denomination = 1 ether;\r\n\r\n    uint256 public nextLeafIdx = 0;\r\n    mapping(uint256 => bool) public roots;\r\n    mapping(uint8 => uint256) lastLevelHash;\r\n    mapping(uint256 => bool) public nullifierHashes;\r\n    mapping(uint256 => bool) public commitments;\r\n    \r\n    uint256[10] levelDefaults = [\r\n        23183772226880328093887215408966704399401918833188238128725944610428185466379,\r\n        24000819369602093814416139508614852491908395579435466932859056804037806454973,\r\n        90767735163385213280029221395007952082767922246267858237072012090673396196740,\r\n        36838446922933702266161394000006956756061899673576454513992013853093276527813,\r\n        68942419351509126448570740374747181965696714458775214939345221885282113404505,\r\n        50082386515045053504076326033442809551011315580267173564563197889162423619623,\r\n        73182421758286469310850848737411980736456210038565066977682644585724928397862,\r\n        60176431197461170637692882955627917456800648458772472331451918908568455016445,\r\n        105740430515862457360623134126179561153993738774115400861400649215360807197726,\r\n        76840483767501885884368002925517179365815019383466879774586151314479309584255\r\n    ];\r\n\r\n    event Deposit(uint256 root, uint256[10] hashPairings, uint8[10] pairDirection);\r\n    event Withdrawal(address to, uint256 nullifierHash);\r\n\r\n    constructor(\r\n        address _hasher,\r\n        address _verifier\r\n      \r\n    ){\r\n        hasher = Hasher(_hasher);\r\n        verifier = _verifier;\r\n    }\r\n\r\n    function deposit(uint256 _commitment) external payable nonReentrant {\r\n        require(msg.value == denomination, \"increatese the amount of eth\");\r\n        require(!commitments[_commitment], \"existing-commitment\");\r\n        require(nextLeafIdx < 2 ** treeLevel, \"tree-full\");\r\n\r\n        uint256 newRoot;\r\n        uint256[10] memory hashPairings;\r\n        uint8[10] memory hashDirections;\r\n\r\n        uint256 currentIdx = nextLeafIdx;\r\n        uint256 currentHash = _commitment;\r\n\r\n        uint256 left;\r\n        uint256 right;\r\n        uint256[2] memory ins;\r\n        \r\n        for(uint8 i = 0; i < treeLevel; i++){\r\n            \r\n            if(currentIdx % 2 == 0){\r\n                left = currentHash;\r\n                right = levelDefaults[i];\r\n                hashPairings[i] = levelDefaults[i];\r\n                hashDirections[i] = 0;\r\n            }else{\r\n                left = lastLevelHash[i];\r\n                right = currentHash;\r\n                hashPairings[i] = lastLevelHash[i];\r\n                hashDirections[i] = 1;\r\n            }\r\n            lastLevelHash[i] = currentHash;\r\n\r\n            ins[0] = left;\r\n            ins[1] = right;\r\n\r\n            (uint256 h) = hasher.MiMC5Sponge{ gas: 150000 }(ins, _commitment);\r\n\r\n            currentHash = h;\r\n            currentIdx = currentIdx / 2;\r\n        }\r\n\r\n        newRoot = currentHash;\r\n        roots[newRoot] = true;\r\n        nextLeafIdx += 1;\r\n\r\n        commitments[_commitment] = true;\r\n        emit Deposit(newRoot, hashPairings, hashDirections);\r\n    }\r\n\r\n    function withdraw(\r\n        uint[2] memory a,\r\n        uint[2][2] memory b,\r\n        uint[2] memory c,\r\n        uint[2] memory input\r\n    ) external payable nonReentrant {\r\n        uint256 _root = input[0];\r\n        uint256 _nullifierHash = input[1];\r\n\r\n        require(!nullifierHashes[_nullifierHash], \"already-spent\");\r\n        require(roots[_root], \"not-root\");\r\n\r\n        uint256 _addr = uint256(uint160(msg.sender));\r\n\r\n        (bool verifyOK, ) = verifier.call(abi.encodeCall(IVerifier.verifyProof, (a, b, c, [_root, _nullifierHash, _addr])));\r\n\r\n        require(verifyOK, \"invalid-proof\");\r\n\r\n        nullifierHashes[_nullifierHash] = true;\r\n        address payable target = payable(msg.sender);\r\n\r\n        (bool ok, ) = target.call{ value: denomination }(\"\");\r\n\r\n        require(ok, \"payment-failed\");\r\n\r\n        emit Withdrawal(msg.sender, _nullifierHash);\r\n    }\r\n                \r\n}"
    },
    "contracts/verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 9195021042278933172446394421702167244346965218605255476921164112659251221177;\n    uint256 constant alphay  = 8792598133334715920827793834737610834578165727778706356132097993397125851658;\n    uint256 constant betax1  = 12476991183148770300351888235570482037418733163750405863789266190447327896927;\n    uint256 constant betax2  = 4588672682928019373349957372861494288556632204327008441817526221020130074929;\n    uint256 constant betay1  = 14024654644845092316465499011272539865139994325250861083683336349285038848561;\n    uint256 constant betay2  = 15111774571023661616595270291541169401803017898425572126574777727143833318000;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant deltax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant deltay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant deltay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    \n    uint256 constant IC0x = 2502289850785184832398231181860575906101366558163247819982056700872724005819;\n    uint256 constant IC0y = 11810736046499745167467151923448079594910388883754528171799411217130825486960;\n    \n    uint256 constant IC1x = 3926701609347900553451620007425605819973532511543666607677996535979450810338;\n    uint256 constant IC1y = 14920695973032794844783916876804221455971927353968895375656317332127107336370;\n    \n    uint256 constant IC2x = 401512696046823088707567146838901994469375655734506155894185681310389735657;\n    uint256 constant IC2y = 14591437697752340132545167804359733167356788427604185413243854698994364648137;\n    \n    uint256 constant IC3x = 11481486560255105223028234270925329389916398961213491329367211906251860778680;\n    uint256 constant IC3y = 21812657173593168717063609204086076684196503874610814935269463151047723036251;\n    \n \n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[3] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n            \n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n                \n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                \n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                \n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                \n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations âˆˆ F\n            \n            checkField(calldataload(add(_pubSignals, 0)))\n            \n            checkField(calldataload(add(_pubSignals, 32)))\n            \n            checkField(calldataload(add(_pubSignals, 64)))\n            \n            checkField(calldataload(add(_pubSignals, 96)))\n            \n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}