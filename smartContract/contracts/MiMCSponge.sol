// // SPDX-License-Identifier: UNLICENSED
// pragma solidity =0.8.17;


// import "./interfaces/IMiMCSponge.sol";




// // we are implementing the MIMCSponge; 
// contract HasherSponge is IMiMCSponge {

 
     

//     uint8  private nRounds = 20;
//     // the prime field from 
//     uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;


//     // so the first thing we have to do is we need to have the c .. the constants 
//     // c is the constant for the MIMC

//     uint256[20] private c  = [
         
//         0,
//         50281665087298506398025612566576429713867677490132600550666462694043893096041,
//         103379909872542805421140796569816612169295853039398864686417708805632325131067,
//         8586855295369424941935330807803134896681691157372145643883923355615550583342,
//         88370656788028663357054378704610607924064488825154270360610943785853808437587,
//         80176421270384287601374674158600932358010734845730789240551909743287128659181,
//         9528216501708403574105991674956722258584542856277612000094300594947363066680,
//         17669521326439010530034895428020811097501471394802251414069319741829373029771,
//         58631108220768371139580724699814589444344114830955946945895965299721834508558,
//         95100372926602787001593384948116402864394899303403306696193376400358861223081,
//         107818123855601272583072257161782347474009303555329756033680199767831149000646,
//         1428802693023461914036224180230354801713259560901182204682110762944690749665,
//         98212930817416947604707053186021029626372029290120295000826942586189933631243,
//         77616516200106068767337201799487094912595296259220362763818164121851717084940,
//         58083512051912905109576180677305052842815684860310822645756294409625272816797,
//         105110014696781952118374891655100624045293309813267472668843831137609860690906,
//         63510890172120891876331835536756515461281359754185699836571235972391984807120,
//         71776992183853185402707224684473119966100872667793758637767495260560955881686,
//         38521477329328306708598228213328859227759684577497015037882397799544926522561,
//         26398687503444292499683437635338801937597812449300890475753400819372208451565


    
//     ];



 
// function createNewHashFromTwo( uint256[2] memory inputs,  uint256 k) public view  returns(uint256){

  


//     uint256 rBits = 0;
//     uint256 cBits = 0;

//     for (uint256 i = 0; i<inputs.length; i++){
               
//          rBits =  addmod(rBits, inputs[i] , p);

//             (rBits, cBits) = mimcHasherFeistal(rBits, cBits, k);



//     }
     
//     return rBits;




// }

//   // lets create the function MIMC = (x + k + c) ^5 but for each roun
// function mimcHasherFeistal(uint256 _iL, uint256 _iR, uint256 k) public  view returns(uint256, uint256){
//           uint256 lastR = _iR;
//           uint256 lastL = _iL;
       

//           uint base;
//           uint base2;
//           uint256 base4;
//           uint256 temp;
 
          
          
//           for (uint256 i = 0; i< nRounds; i++){
//             // x + k+  c
//             // at index 0    c = 0 
//             base = addmod(lastR, k, p );
//             base = addmod(base , c[i],p);
//             base2 = mulmod(base, base, p);
//             base4 = mulmod(base2, base2, p);
           

//             temp = lastR;

//             lastR =  addmod(mulmod(base4, base2, p), lastL, p );
//             lastL = temp;

                  
//           }

//           return (lastL, lastR);



    
// }



// }





pragma solidity =0.8.17;

contract Hasher {
    uint256 p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256[20] c = [
        0,
        25823191961023811529686723375255045606187170120624741056268890390838310270028,
        71153255768872006974285801937521995907343848376936063113800887806988124358800,
        51253176922899201987938365653129780755804051536550826601168630951148399005246,
        66651710483985382365580181188706173532487386392003341306307921015066514594406,
        45887003413921204775397977044284378920236104620216194900669591190628189327887,
        14399999722617037892747232478295923748665564430258345135947757381904956977453,
        29376176727758177809204424209125257629638239807319618360680345079470240949145,
        13768859312518298840937540532277016512087005174650120937309279832230513110846,
        54749662990362840569021981534456448557155682756506853240029023635346061661615,
        25161436470718351277017231215227846535148280460947816286575563945185127975034,
        90370030464179443930112165274275271350651484239155016554738639197417116558730,
        92014788260850167582827910417652439562305280453223492851660096740204889381255,
        40376490640073034398204558905403523738912091909516510156577526370637723469243,
        903792244391531377123276432892896247924738784402045372115602887103675299839,
        112203415202699791888928570309186854585561656615192232544262649073999791317171,
        114801681136748880679062548782792743842998635558909635247841799223004802934045,
        111440818948676816539978930514468038603327388809824089593328295503672011604028,
        64965960071752809090438003157362764845283225351402746675238539375404528707397,
        98428510787134995495896453413714864789970336245473413374424598985988309743097
    ];

    function MiMC5Feistel(uint256 _iL, uint256 _iR, uint256 _k) internal view returns(uint256 oL, uint256 oR) {
        uint8 nRounds = 20;

        uint256 lastL = _iL;
        uint256 lastR = _iR;

        uint256 mask;
        uint256 mask2;
        uint256 mask4;
        uint256 temp;

        for(uint8 i = 0; i < nRounds; i++){
            mask = addmod(lastR, _k, p);
            mask = addmod(mask, c[i], p);
            mask2 = mulmod(mask, mask, p);
            mask4 = mulmod(mask2, mask2, p);
            mask = mulmod(mask4, mask, p);

            temp = lastR;
            lastR = addmod(lastL, mask, p);
            lastL = temp;
        }

        return (lastL, lastR);
    }
    function MiMC5Sponge(uint256[2] memory _ins, uint256 _k) external view returns(uint256 h) {
        uint256 lastR = 0;
        uint256 lastC = 0;

        for(uint8 i = 0; i < _ins.length; i++){
            lastR = addmod(lastR, _ins[i], p);
            (lastR, lastC) = MiMC5Feistel(lastR, lastC, _k);
        }

        h = lastR;
    }
}